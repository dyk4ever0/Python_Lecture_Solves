# -*- coding: utf-8 -*-
"""10

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GRCKr6g260SN6rIVs7fBAu9QJH6-eDK2

감시카메라 (2021.01.20 10am 변경) (10-1)
감시 카메라의 사각지대를 찾는 문제입니다. dfs 개념이 적용되며 난이도 조절이 필요합니다. dfs가 아니라 해당 카메라의 사각지대 찾는 정도로 문제를 수정하면 사용 가능할 것 같습니다. 해당 문제는 input 이 필요합니다. https://www.acmicpc.net/problem/15683 를 참고해주세요 colab에서 실행하지 말고 개인 ide나 파이썬 editor에서 돌려보시는 것이 좋습니다.
"""

#initial condition

camera_list=[]
map_data=[]
map_string=[
    "2 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 6 6 6 6",
    "6 6 6 6 6 6 6 6 6 6 6 6 6 0 6 0 6 0 0 0",
    "1 0 0 0 0 0 0 6 0 0 0 0 6 0 6 0 0 0 5 0",
    "0 6 5 0 0 5 0 6 0 5 0 0 6 0 6 0 6 0 0 0",
    "0 6 0 0 0 0 0 6 0 0 0 1 6 0 6 0 6 2 0 0",
    "0 6 0 0 0 0 0 6 2 0 0 0 6 0 6 0 6 6 6 6",
    "0 6 6 6 6 6 6 6 0 0 0 0 6 0 6 0 0 0 0 2",
    "0 0 0 0 0 0 0 0 0 0 0 2 6 0 0 0 6 6 6 6",
    "0 0 5 0 0 5 0 0 0 5 0 0 6 0 6 0 6 0 0 0",
    "0 0 0 0 0 0 0 0 0 0 0 0 6 0 6 0 6 0 5 0",
    "6 6 6 6 0 0 6 6 6 6 6 6 6 0 0 0 6 0 0 0",
    "0 5 0 6 0 0 6 0 0 0 2 0 0 0 6 0 6 0 5 0",
    "0 0 0 0 0 0 6 4 0 0 0 0 0 0 6 0 6 0 0 0",
    "0 5 0 0 0 0 6 0 0 0 0 5 0 0 6 2 0 0 0 0",
    "0 0 0 6 0 0 6 0 5 0 0 0 0 0 6 0 6 0 5 0",
    "3 0 0 6 0 1 6 0 0 0 4 0 0 3 6 1 6 0 0 0"
]


n=len(map_string)
for i in range(n):
    map_data.append(list(map(int, map_string[i].split())))
m=len(map_data[0])


def find_camera(map):
    for i in range(len(map)):
        for j in range(len(map[i])):
            if (map[i][j] != 0 and map[i][j] != 6):
                camera_list.append((i, j))

find_camera(map_data)
print(camera_list)

def find_blindspot(map):
    count = 0
    for i in map:
        for j in i:
            if j == 0:
                count += 1
    return count

def check_cameraspot():
    #카메라 리스트 순회
    for camera_pos in camera_list:
        x=camera_pos[0]
        y=camera_pos[1]
        camera=map_data[x][y]
        if camera==1:
            detect(x, y, 'top')
            detect(x, y, 'down')

        if camera==2:
            detect(x, y, 'left')
            detect(x, y, 'right')

        if camera==3:
            detect(x, y, 'top_right')
            detect(x, y, 'down_left')

        if camera==4:
            detect(x, y, 'down_right')
            detect(x, y, 'top_left')

        if camera==5:
            directions = ['top', 'down', 'left', 'right', 'top_right', 'top_left', 'down_right', 'down_left']
            for i in directions :
                detect(x, y, i)

def inside_map(x, y):
    return x in range(0, n) and y in range(0, m)

def is_not_camera(x, y):
    return (x, y) not in camera_list

def detect(x, y, direction):
    #위
    if direction=='top':
        while inside_map(x, y):
            if(map_data[x][y]==6):
                break
            if is_not_camera(x, y):
                map_data[x][y]=7
            x-=1
    #아래
    elif direction=='down':
        while inside_map(x, y):
            if(map_data[x][y]==6):
                break
            if is_not_camera(x, y):
                map_data[x][y]=7
            x+=1
    #왼쪽
    elif direction=='left':
        while inside_map(x, y):
            if(map_data[x][y]==6):
                break
            if is_not_camera(x, y):
                map_data[x][y]=7
            y-=1
    #오른쪽
    elif direction=='right':
        while inside_map(x, y):
            if(map_data[x][y]==6):
                break
            if is_not_camera(x, y):
                map_data[x][y]=7
            y+=1
    #우상
    elif direction=='top_right':
        while inside_map(x, y):
            if (map_data[x][y] == 6):
                break
            if is_not_camera(x, y):
                map_data[x][y] = 7
            x-=1
            y+=1
    #우하
    elif direction=='down_right':
        while inside_map(x, y):
            if (map_data[x][y] == 6):
                break
            if is_not_camera(x, y):
                map_data[x][y] = 7
            x+=1
            y+=1
    #좌하
    elif direction=='down_left':
        while inside_map(x, y):
            if (map_data[x][y] == 6):
                break
            if is_not_camera(x, y):
                map_data[x][y] = 7
            x+=1
            y-=1
    #좌상
    elif direction=='top_left':
        while inside_map(x, y):
            if (map_data[x][y] == 6):
                break
            if is_not_camera(x, y):
                map_data[x][y] = 7
            x-=1
            y-=1

check_cameraspot()

for i in map_data:
    print(i)
print(find_blindspot(map_data))

"""Convex Hull 알고리즘 - 드론으로 군중 둘러싸기(10-2)
난이도 최상... (만약에 이 문제 관련해서 진행한다면 역대 난이도 중 최상이 될 것 같습니다.)

알고리즘 자체는 어렵지 않지만 수학 개념이 어렵습니다.

convex hull 알고리즘입니다. 여러 점들 가운데 볼록 다각형으로 다른 모든 점들을 둘러 쌓을 수 있는 점의 집합을 구하는 알고리즘 입니다.

자세한 설명은 https://www.crocus.co.kr/1288 를 참고해 주세요
"""

from math import atan2, sqrt
from math import pi
import matplotlib.pyplot as plt



point_list=[
    (-2, 2), (1, 1), (3, 3), (4, 2), (6, 4), (7, 3), (-1, -1), (1, -1), (2, -3), (5, -2)
]


'''
n=int(input())
point_list=[]
for i in range(n):
    x, y=map(int, input().split())
    point_list.append((x, y))
'''
stack=[]

print(point_list)

for point in point_list:
    plt.scatter(point[0], point[1], color='black')
plt.show()

def isCounterclockwise(x1, y1, x2, y2, x3, y3):
    temp=x1*y2+x2*y3+x3*y1
    temp=temp-(x2*y1+x3*y2+x1*y3)
    if(temp>0):
        return 1
    elif(temp<0):
        return -1
    else:
        return 0

def find_origin(point_list_t):
    minIndex=[0]
    for i in range(1, len(point_list_t)):
        if point_list_t[i][1]<point_list_t[minIndex[0]][1]:
            minIndex.clear()
            minIndex.append(i)
        elif point_list_t[i][1]==point_list_t[minIndex[0]][1]:
            minIndex.append(i)

    if len(minIndex)==1:
        return minIndex[0], point_list_t[minIndex[0]]
    #y값이 같은게 있으면 그 중 x 값이 제일 작은 것을 return
    else:
        index=0
        for i in range(1, len(minIndex)):
            if point_list_t[i][0]<point_list_t[index][0]:
                index=i
        return index, point_list_t[index]

def draw_present_status(point_list_t, point_stack):
    x_values=[]
    y_values=[]
    for point in point_list_t:
        plt.scatter(point[0], point[1], color='black')

    for point in point_stack:
        x_values.append(point[0])
        y_values.append(point[1])
    plt.plot(x_values, y_values, color='green')
    plt.show()

#각도 구하기
angle_list=[]

#시작 좌표 찾기
origin_index, origin_point=find_origin(point_list)
for i in range(len(point_list)):
    dy=point_list[i][1]-origin_point[1]
    dx=point_list[i][0]-origin_point[0]
    angle_list.append(atan2(dy, dx)*180/pi)


#각도에 따라 포인트 정렬
zipped_list=zip(angle_list, point_list)
sorted_zipped_list=sorted(zipped_list)
sorted_point_list=[element for _, element in sorted_zipped_list]
print(sorted_point_list)




stack.append(sorted_point_list[0])
stack.append(sorted_point_list[1])

for i in range(2, len(sorted_point_list)):
    while(True):
        sp=stack.pop()
        fp=stack.pop()
        if isCounterclockwise(fp[0], fp[1], sp[0], sp[1], sorted_point_list[i][0], sorted_point_list[i][1])>0:
            stack.append(fp)
            stack.append(sp)
            break
        else:
            stack.append(fp)
    stack.append(sorted_point_list[i])
    draw_present_status(sorted_point_list, stack)

#last picture
stack.append(sorted_point_list[0])
draw_present_status(sorted_point_list, stack)

"""Greedy 2
주유소 문제 - 최단 비용 찾기
"""

distance=[2, 3, 1]
price=[5, 2, 4, 1]

def find_minIndex(array):
    minIndex=0
    for i in range(len(array)):
        if array[i]<array[minIndex]:
            minIndex=i
    return minIndex

total_price=0
price_wo_dest=price[:-1]
#최소 가격 찾기

#recursion version
def find_min_price(dist_list, price_list):
    global total_price
    if (len(price_list) == 0): 
        return

    elif(len(price_list)==1):
        total_price+=dist_list[0]*price_list[0]
        return

    else:
        index=find_minIndex(price_list)
        for i in range(index, len(dist_list)):
            total_price+=price_list[index]*dist_list[i]

        find_min_price(dist_list[:index], price_list[:index])

find_min_price(distance, price_wo_dest)
print(total_price)





#non recursion version
total_price=0
price=price[:len(price)-1]

index=find_minIndex(price)
last_index=len(distance)
while(len(price)!=0):
    index=find_minIndex(price)
    for i in range(index, len(distance)):
        total_price+=price[index]*distance[i]
    price=price[:index]
    distance = distance[:index]
print(total_price)

"""연구실 문제 (10-3)
특정 위치에 유해가스가 뿌려졌을 때 안전한 장소를 찾아라
"""

#연구소 문제
#벽과 독성 물질로 이루어진 데이터
#독성 물질은 벽을 통과해 퍼질 수 없다.
#데이터를 보고 연구실에서 독이 퍼지지 않는 안전 지대를 구하라 (Dfs + 재귀)


# 10 10
string=[
    "0 0 1 0 0 0 0 0 0 0",
    "2 1 0 1 1 1 1 1 0 0",
    "0 1 0 0 1 0 0 1 0 0",
    "0 1 0 0 1 0 0 1 1 1",
    "1 1 0 2 1 0 0 0 0 0",
    "0 0 0 0 0 1 0 1 1 1",
    "1 1 1 0 1 0 0 0 0 0",
    "0 0 0 0 0 1 0 1 1 0",
    "1 1 1 0 1 1 1 1 0 1",
    "0 0 0 2 0 0 0 0 0 0",
]

data=[]
# n, m=map(int, input().split())
Polluted=3
for i in range(len(string)):
    data.append(list(map(int, string[i].split(" "))))
n=len(data)
m=len(data[0])
print(n, m)
# data=[[0 for i in range(m)] for i in range(n)]

# for i in range(n):
#     data[i]=list(map(int, input().split()))


print('--------초기 상태--------')
for i in data:
    print(i)

def find_safezone(map_data):
    count=0
    for i in range(len(map_data)):
        for j in range(len(map_data[i])):
            if(map_data[i][j]==0):
                count+=1
    return count

print(find_safezone(data))



def infection(x, y):
    if x not in range(0, n) or y not in range(0, m):
        return False

    if data[x][y]==1:
        return False

    if data[x][y]==0 or data[x][y]==2:
        if(data[x][y]!=2):
            data[x][y]=Polluted
        infection(x-1, y)
        infection(x+1, y)
        infection(x, y-1)
        infection(x, y+1)
        return True
    return False

for i in range(n):
    for j in range(m):
        if(data[i][j]==2):
            infection(i, j)


print('--------감염 상태--------')
for i in data:
    print(i)
print(find_safezone(data))

# 10 10 , 4가목표지점, 3이 로봇
string = [
   "0 0 1 0 0 0 0 0 0 0",
   "0 1 0 1 1 1 1 1 0 0",
   "4 1 3 0 0 0 0 1 0 0",
   "0 1 0 0 1 0 0 1 1 1",
   "0 1 1 1 1 0 0 0 0 3",
   "0 0 0 0 0 1 0 1 1 1",
   "1 1 1 1 0 0 0 0 0 0",
   "0 0 0 0 0 1 0 1 0 0",
   "1 1 0 0 1 1 1 1 0 1",
   "1 0 0 0 0 3 0 1 0 0",
]
data=[]
robot_list=[]
dx = [0, 0, -1, 1]
dy = [1, -1, 0, 0]
queue=[]
# n, m=map(int, input().split())
for i in range(len(string)):
   data.append(list(map(int, string[i].split(" "))))
dist_data=[[0 for i in range(len(data[0]))] for j in range(len(data))]
for i in data:
   print(i)
print()

def find_robot():
   for i in range(len(data)):
       for j in range(len(data[0])):
           if(data[i][j]==3):
               robot_list.append((i, j))
def reset_data(array):
   for i in range(len(array)):
       for j in range(len(array[i])):
           array[i][j]=0
def bfs(x, y):
   queue.append((x, y))
   dist_data[x][y]=1
   while(queue):
       pos=queue.pop(0)
       a, b=pos[0], pos[1]
       #동서남북
       for k in range(4):
           i=a+dx[k]
           j=b+dy[k]
           if i in range(0, len(data)) and j in range(0, len(data[0])) and data[i][j]!=1 and dist_data[i][j]==0:
               queue.append((i, j))
               dist_data[i][j]=dist_data[a][b]+1
find_robot()
result=[]
for coord in robot_list:
   reset_data(dist_data)
   bfs(coord[0], coord[1])
   result.append(dist_data[2][0]) #폭탄 위치까지의 거리 출력
   for i in range(len(dist_data)):
       for j in range(len(dist_data[i])):
           print("%-3d"%dist_data[i][j], end=' ')
       print()
   print()
print(min(result))