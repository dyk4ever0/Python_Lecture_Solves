# -*- coding: utf-8 -*-
"""8-4

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Sb7hbdTrEx8TUviK9tk7Ny8r3qtgciDX
"""

import heapq
from collections import defaultdict
import matplotlib.pyplot as plt
import networkx as nx
#data
myGraph=defaultdict(dict)

class GraphControl:
    def __init__(self):
        self.visual=[]

    def addEdges(self, start, end, dist):
        myGraph[start].update({end: dist})
        myGraph[end].update({start: dist})
        temp=[start, end, dist]
        self.visual.append(temp)

    def visualize(self):
        G=nx.Graph()
        for item in self.visual:
            u, v, weight = item
            G.add_edge(u, v, weight=weight)
        pos={
            'A': (1, 3),
            'B': (2, 2),
            'C': (3, 1),
            'D': (2, 5),
            'E': (3, 4),
            'F': (4, 3),
            'G': (3, 7),
            'H': (4, 6),
            'I': (5, 5),
            'J': (4.5, 7)
        }
        eLa=nx.get_edge_attributes(G, 'weight')
        nx.draw_networkx_nodes(G, pos)
        nx.draw_networkx_edges(G, pos)
        nx.draw_networkx_labels(G, pos)
        nx.draw_networkx_edge_labels(G, pos, edge_labels=eLa, font_size=10)
        plt.show()

G=GraphControl()
G.addEdges('A', 'D', 3)
G.addEdges('B', 'E', 2)
G.addEdges('C', 'F', 4)
G.addEdges('D', 'E', 4)
G.addEdges('E', 'F', 5)
G.addEdges('D', 'G', 1)
G.addEdges('G', 'E', 1)
G.addEdges('E', 'H', 2)
G.addEdges('G', 'H', 3)
G.addEdges('H', 'F', 4)
G.addEdges('F', 'I', 2)
G.addEdges('H', 'I', 1)
G.addEdges('G', 'J', 4)
G.addEdges('H', 'J', 5)
G.addEdges('I', 'J', 3)
G.visualize()

#mission1
def dijkstra(graph, startNode):
    distances=dict()
    for node in graph:
        distances[node]=float("inf")

    distances[startNode]=0

    queue=[]
    heapq.heappush(queue, [distances[startNode], startNode])

    while queue:
        
        current_distance, current_node=heapq.heappop(queue)

        for adjacent, weight in graph[current_node].items():

            distance=current_distance + weight
            if distance < distances[adjacent]:
                distances[adjacent]=distance

                #data
                for key in distances:
                    print
                    print("%c : %3.0f"%(key,distances[key]), end='  ')
                print()
                heapq.heappush(queue, [distance, adjacent])

    return distances

print('A를 거쳐 가는 길 : ', dijkstra(myGraph, 'A')['J'])
print('B를 거쳐 가는 길 : ', dijkstra(myGraph, 'B')['J'])
print('C를 거쳐 가는 길 : ', dijkstra(myGraph, 'C')['J'])

import heapq
from collections import defaultdict
import matplotlib.pyplot as plt
import networkx as nx

#그래프 데이터 초기화
myGraph=defaultdict(dict)
#그래프 시각화 및 데이터 추가를 위한 클래스 정의 (학습자에게는 보여주지 않아도 됨)
class GraphControl:
    def __init__(self):
        self.visual=[]

    def addEdges(self, start, end, dist):
        myGraph[start].update({end: dist})
        myGraph[end].update({start: dist})
        temp=[start, end, dist]
        self.visual.append(temp)

    def visualize(self):
        G=nx.Graph()
        for item in self.visual:
            u, v, weight = item
            G.add_edge(u, v, weight=weight)
        #pos=nx.circular_layout(G)
        pos={
            'A': (1, 3),
            'B': (2, 2),
            'C': (3, 1),
            'D': (2, 5),
            'E': (3, 4),
            'F': (4, 3),
            'G': (3, 7),
            'H': (4, 6),
            'I': (5, 5),
            'J': (4.5, 7)
        }
        eLa=nx.get_edge_attributes(G, 'weight')
        nx.draw_networkx_nodes(G, pos)
        nx.draw_networkx_edges(G, pos)
        nx.draw_networkx_labels(G, pos)
        nx.draw_networkx_edge_labels(G, pos, edge_labels=eLa, font_size=10)
        #G.add_edges_from(self.visual)
        #nx.draw_networkx(G)
        plt.show()

G=GraphControl()
G.addEdges('A', 'D', 3)
G.addEdges('B', 'E', 2)
G.addEdges('C', 'F', 4)
G.addEdges('D', 'E', 4)
G.addEdges('E', 'F', 5)
G.addEdges('D', 'G', 1)
G.addEdges('G', 'E', 1)
G.addEdges('E', 'H', 2)
G.addEdges('G', 'H', 3)
G.addEdges('H', 'F', 4)
G.addEdges('F', 'I', 2)
G.addEdges('H', 'I', 1)
G.addEdges('G', 'J', 4)
G.addEdges('H', 'J', 5)
G.addEdges('I', 'J', 3)
G.visualize()



print('A, B, C 중 어떤 곳을 선택하여 가는 것이 제일 효과적일까? ')
#정답 코드 부분
def dijkstra(graph, startNode):
    # distance 딕셔너리 생성를 현재 그래프의노드 개수만큼 생성해보세요. 딕셔너리의 키는 node이고 value는 거리입니다.
    # value를 초기화 할 때는 float("inf")를 이용해 무한대로 나타내 보세요.
    distances=dict()
    for node in graph:
        distances[node]=float("inf")

    #시작점의 거리값을 0으로 초기화해보세요. (시작점에서 시작점까지의 거리는 0입니다.)
    distances[startNode]=0



    # heap, 즉 우선순위 큐를 만듭니다.. (heapq.heappop, heapq.heappush를 이용하면 거리가 가장 작은 값부터 pop할 수 있습니다.)
    queue=[]
    heapq.heappush(queue, [distances[startNode], startNode])

    #이후 큐가 빌 때까지 pop합니다. (while문 안에 코드를 작성하며 다익스트라 알고리즘을 완성해 봅시다.)
    while queue:
        
        #heap에 있는 현재 큐에 있는 값 중 거리가 가장 작은 값을 pop하여 current_distance와 current_node로 설정해 보세요.
        current_distance, current_node=heapq.heappop(queue)

        #current_node의 인접 노드를 반복문으로 확인한다. 이 때 인접 노드와 그 가중치를 변수로 선언합니다.
        for adjacent, weight in graph[current_node].items():

            #현재 노드까지의 최단거리와 (현재노드와 인접노드까지의 거리) < 인접노드까지의 최단거리 라면 인접노드까지의 최단거리를 update해보세요.   
            distance=current_distance + weight
            if distance < distances[adjacent]:
                distances[adjacent]=distance

                #현재 distance 리스트 값 확인 - 미리 작성된 코드
                for key in distances:
                    print
                    print("%c : %3.0f"%(key,distances[key]), end='  ')
                print()
                heapq.heappush(queue, [distance, adjacent])

    return distances

print('A를 거쳐 가는 길 : ', dijkstra(myGraph, 'A')['J'])
print('B를 거쳐 가는 길 : ', dijkstra(myGraph, 'B')['J'])
print('C를 거쳐 가는 길 : ', dijkstra(myGraph, 'C')['J'])